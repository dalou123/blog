(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{493:function(v,t,_){"use strict";_.r(t);var a=_(1),r=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[v._v("#")]),v._v(" 背景")]),v._v(" "),t("p",[v._v("为什么浏览器要设置垃圾回收机制："),t("br"),v._v("\n在chrome浏览器中，javascript中的V8引擎可以使用的内存大小是被限制的。且不同操作系统对应分配的内存大小就不同（针对32位和64位的操作系统），内存范围大致在 0.7G-1.4G。\n1.浏览器本身是web应用，不考虑持久化缓存，所以就需要一个垃圾回收机制，来实现变量的用完即抛，节省内存；\n垃圾回收机制需要解决的问题：阻塞问题。\n因为JS引擎是单线程，而垃圾回收会阻塞JS的线程。目前V8一次回收1.5G的堆内存占用时间是50ms，因此如果内存过大，那么垃圾回收的时间就会增长，造成阻塞时间增长。")]),v._v(" "),t("h2",{attrs:{id:"一、v8之前的垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、v8之前的垃圾回收"}},[v._v("#")]),v._v(" 一、V8之前的垃圾回收")]),v._v(" "),t("h3",{attrs:{id:"_1-引用计数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用计数"}},[v._v("#")]),v._v(" 1. 引用计数")]),v._v(" "),t("p",[v._v('语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。\n引用计数算法优点：')]),v._v(" "),t("ul",[t("li",[v._v("引用计数为零时，发现垃圾立即回收；")]),v._v(" "),t("li",[v._v("最大限度减少程序暂停；")])]),v._v(" "),t("p",[v._v("引用计数算法缺点：")]),v._v(" "),t("ul",[t("li",[v._v("无法回收循环引用的对象；")]),v._v(" "),t("li",[v._v("空间开销比较大；")])]),v._v(" "),t("h3",{attrs:{id:"_2-标记清除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-标记清除"}},[v._v("#")]),v._v(" 2. 标记清除")]),v._v(" "),t("p",[v._v("按照变量是否进入“环境”，如果离开执行环境就认为是垃圾。因此，这样就能解决引用计数方式中循环引用的问题，因为两个循环引用的变量都离开了执行环境作用域。但是对于内存碎片的问题并没有解决。\n分标记和清除两个阶段完成。\n对比引用计数算法，标记清除算法最大的优点是能够回收循环引用的对象问题，内存碎片问题")]),v._v(" "),t("h2",{attrs:{id:"二、v8之后的垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、v8之后的垃圾回收"}},[v._v("#")]),v._v(" 二、V8之后的垃圾回收")]),v._v(" "),t("p",[v._v("将需要回收的垃圾数据进行分类：新生代和老生代。")]),v._v(" "),t("h3",{attrs:{id:"分代回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分代回收"}},[v._v("#")]),v._v(" 分代回收")]),v._v(" "),t("p",[v._v("为了更快的提高垃圾回收的效率，V8引擎针对不同的数据采用不同的回收方式。按照数据存活时间长短将数据划分为两类：临时变量 和 长期对象")]),v._v(" "),t("p",[t("strong",[v._v("临时对象")]),v._v(":")]),v._v(" "),t("blockquote",[t("p",[v._v("通常函数中声明的变量，块级作用域中声明的变量，这些变量可能很快就不再使用了，因此为了保证后续有足够内存接纳新变量，所以要对已存在的临时变量增加回收频率。")])]),v._v(" "),t("p",[t("strong",[v._v("长久对象")]),v._v(":")]),v._v(" "),t("blockquote",[t("p",[v._v("全局对象，事件回调")])]),v._v(" "),t("p",[v._v("针对这两类不同的数据，存储在不同的存储空间中，对应着不同的回收策略:")]),v._v(" "),t("ul",[t("li",[v._v("将存在临时变量的区域称为新生代区域 - 对应回收策略：副垃圾回收")]),v._v(" "),t("li",[v._v("将存储长期变量的区域称为老生代区域 - 对应垃圾回收策略：主垃圾回收器。")])]),v._v(" "),t("h3",{attrs:{id:"新生代回收策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新生代回收策略"}},[v._v("#")]),v._v(" 新生代回收策略")]),v._v(" "),t("p",[v._v("新生代存储空间的回收策略 - 【scanvenge算法】\n针对生命周期短的数据，主要的策略是：使用低内存空间的同时，提高回收频率。因此给新生代的数据分配了64MB的存储空间。\n"),t("strong",[v._v("回收算法：scanvenge复制算法")]),v._v("\n将64MB分为两个部分，from和to分别作为使用和缓存复制区域")]),v._v(" "),t("p",[v._v("优点：回收快 缺点：至少一半的空间是要等待复制的，造成浪费。")]),v._v(" "),t("h3",{attrs:{id:"老生代回收策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#老生代回收策略"}},[v._v("#")]),v._v(" 老生代回收策略")]),v._v(" "),t("p",[v._v("老生代存储空间的回收策略 - 【标记-清除】"),t("br"),v._v("\n怎么判定老生代：一轮GC还存活的新生代需要晋升为老生代."),t("br"),v._v("\n老生代使用Mark-Sweep和Mark-Compact算法进行垃圾回收")]),v._v(" "),t("p",[t("strong",[v._v("Mark-Seep")])]),v._v(" "),t("blockquote",[t("p",[v._v("标记-清除法是一种非常基础和常见的垃圾收集算法，该算法是J.McCarthy等人在1960年提出并应用于Lisp语言。当堆中的有效内存空间被耗尽后，会停止整个程序（stop the world），然后进行标记和清除工作。\n标记：收集器(Collector)从引用根节点(Root GC)开始遍历，标记所有被引用的对象即可达对象；\n清除：标记完成后，简单来说未被标记的对象将进行回收处理，释放其内存空间；\n这种方式也有缺点：\n一、效率不高\n二、在进行执行的时候需要停止整个应用进程，用户体验差\n三、这种方式清理出来的内存空间是不连续的，会产生内存碎片\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])]),v._v(" "),t("p",[t("strong",[v._v("Mark-Compact")])]),v._v(" "),t("blockquote",[t("p",[v._v("顾名思义，这是一种标记-整理机制，其标记过程和标记-清楚算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理对象边界以外的内存区域，这样就能得到连续的内存块空间。")])])])}),[],!1,null,null,null);t.default=r.exports}}]);